# Control we check and use the original field type.
go build -C $BITFIELD_DIR -o $TMPDIR/bitfield
exec $TMPDIR/bitfield -in in.go -out out.go -type A
! stderr .
cmp out.go want.a.go

exec $TMPDIR/bitfield -in in.go -out out.go -type B
! stderr .
cmp out.go want.b.go

! exec $TMPDIR/bitfield -in in.go -out out.go -type C
! stdout .
cmp stderr want.c

! exec $TMPDIR/bitfield -in in.go -out out.go -type D
! stdout .
cmp stderr want.d

-- in.go --
package testpkg

type A struct {
	F1 uint16 `bitfield:"2"`
	F2 uint8  `bitfield:"3"`
}

type B struct {
	F1 uint16 `bitfield:"16"`
	F2 uint8  `bitfield:"3"`
}

type C struct {
	F1 int   `bitfield:"16"`
	F2 uint8 `bitfield:"3"`
}

type D struct {
	F1 uint32 `bitfield:"33"`
}

-- want.a.go --
package testpkg

// Code generated by github.com/arl/bitfield. DO NOT EDIT.

type A uint8

func (a A) F1() uint16 {
	return uint16(a & 0x3)
}

func (a *A) SetF1(val uint16) {
	*a &^= 0x3
	*a |= A(val & 0x3)
}

func (a A) F2() uint8 {
	return uint8((a >> 2) & 0x7)
}

func (a *A) SetF2(val uint8) {
	*a &^= 0x7 << 2
	*a |= A(val&0x7) << 2
}
-- want.b.go --
package testpkg

// Code generated by github.com/arl/bitfield. DO NOT EDIT.

type B uint32

func (b B) F1() uint16 {
	return uint16(b & 0xffff)
}

func (b *B) SetF1(val uint16) {
	*b &^= 0xffff
	*b |= B(val & 0xffff)
}

func (b B) F2() uint8 {
	return uint8((b >> 16) & 0x7)
}

func (b *B) SetF2(val uint8) {
	*b &^= 0x7 << 16
	*b |= B(val&0x7) << 16
}
-- want.c --
bitfield, fatal error:
	field 'F1' has an unsupported type int
-- want.d --
bitfield, fatal error:
	field 'F1' can't represent 33 bits with type uint32
