package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strconv"
	"strings"
)

type Field struct {
	Name   string
	Mask   string
	Offset int
	Bits   int   // actual bit count
	Width  uint8 // bits of the argument or return type
}

type StructInfo struct {
	StructName string
	Fields     []Field
	Bits       int   // bits actually used
	Width      uint8 // type width in bits
}

var errTooManyBits = errors.New("too many bits")
var errInvalidFieldSize = errors.New("invalid field size")

var bb bytes.Buffer

func main() {
	var (
		in, out string
		tname   string
		pkgname string
	)

	flag.StringVar(&in, "in", "", "input file name")
	flag.StringVar(&out, "out", "", "output file name (defaults to [in]_bits.go)")
	flag.StringVar(&tname, "type", "all", "struct to converted into bitfield (or all)")
	flag.StringVar(&pkgname, "pkg", "", "package name (defaults to input file package)")
	flag.Parse()

	if in == "" {
		fmt.Fprintf(os.Stderr, "input file must be provided\n")
		os.Exit(1)
	}
	if out == "" {
		s, _ := strings.CutSuffix(in, ".go")
		out = s + "_bits.go"
	}

	// Parse the file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, in, nil, parser.ParseComments)
	checkf(err, "failed to parse %s", in)

	if pkgname == "" {
		pkgname = node.Name.Name
	}

	// Process the AST
	var structs []StructInfo
	ast.Inspect(node, func(n ast.Node) bool {
		t, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		s, ok := t.Type.(*ast.StructType)
		if !ok {
			return true
		}

		structInfo := StructInfo{StructName: t.Name.Name}
		offset := 0
		for _, field := range s.Fields.List {
			blocks := strings.Fields(strings.Trim(field.Tag.Value, "`"))
			for _, b := range blocks {
				if strings.HasPrefix(b, "bitfield:") {
					fieldName := field.Names[0].Name
					val := strings.Trim(b[9:], `"`)
					bitSize, err := strconv.Atoi(val)
					if bitSize <= 0 || bitSize > 63 {
						checkf(errInvalidFieldSize, "invalid bit count for field %s: %s", fieldName, val)
					}
					checkf(err, "failed to parse bit count for field %s: %s", fieldName, val)
					if fieldName != "_" {
						structInfo.Fields = append(structInfo.Fields, Field{
							Name:   fieldName,
							Offset: offset,
							Bits:   bitSize,
							Mask:   fmt.Sprintf("0x%x", 1<<uint64(bitSize)-1),
							Width:  nextpow2(uint8(bitSize)),
						})
					}
					offset += bitSize
				}
			}
		}
		structInfo.Bits = offset
		structs = append(structs, structInfo)
		return false
	})

	if len(structs) == 0 {
		fmt.Fprintf(os.Stderr, "nothing to generate")
		return
	}

	// Generate the file.
	gprintf("package %s\n\n", pkgname)
	gprintf("// Code generated by %s %s. DO NOT EDIT.\n", os.Args[0], strings.Join(os.Args[1:], " "))

	for _, si := range structs {
		si.Width = nextpow2(uint8(si.Bits))
		gprintf(`type %s uint%d`, si.StructName, si.Width)

		// Define the final type
		if si.Bits > 64 {
			checkf(errTooManyBits, "%s has %d bits", si.StructName, si.Bits)
		}

		for _, fi := range si.Fields {
			// Getter
			if fi.Width < 8 {
				fi.Width = 8
			}
			gprintf(`func (s %s) %s() uint%d {`, si.StructName, fi.Name, fi.Width)
			gprintf(`return uint%d((s >> %d) & %s)`, fi.Width, int(si.Width)-(fi.Offset+fi.Bits), fi.Mask)
			gprintf(`}`)
			gprintf(``)

			// Setter
			shift := int(si.Width) - (fi.Offset + fi.Bits)
			gprintf(`func (s %s) Set%s(val uint%d) %s {`, si.StructName, fi.Name, fi.Width, si.StructName)
			mask := fmt.Sprintf("%s << %d", fi.Mask, shift)
			gprintf(`return s ^ %s | (%s(val)&%s)<< %d`, mask, si.StructName, fi.Mask, shift)
			gprintf(`}`)
			gprintf(``)
		}
	}

	buf, err := format.Source(bb.Bytes())
	checkf(err, "go format failed:\n\n%s", bb.String())

	checkf(os.WriteFile(out, buf, 0666), "write failed")
}

func gprintf(format string, args ...any) {
	fmt.Fprintf(&bb, "%s\n", fmt.Sprintf(format, args...))
}

func checkf(err error, format string, args ...any) {
	if err == nil {
		return
	}

	fmt.Fprintf(os.Stderr, "bitfield, fatal error:")
	fmt.Fprintf(os.Stderr, "\n\t%s: %s\n", fmt.Sprintf(format, args...), err)
	os.Exit(1)
}

func nextpow2(n uint8) uint8 {
	n--
	n |= n >> 1
	n |= n >> 2
	n |= n >> 4
	n++
	return n
}
