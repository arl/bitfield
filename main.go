package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strconv"
	"strings"
)

type config struct {
	in, out string
	tname   string
	pkgname string
}

var bb bytes.Buffer

func parseFlags(args []string) (*config, string, error) {
	flags := flag.NewFlagSet("bitfield", flag.ContinueOnError)
	var buf bytes.Buffer
	flags.SetOutput(&buf)

	var cfg config

	flags.StringVar(&cfg.in, "in", "", "input file name")
	flags.StringVar(&cfg.out, "out", "", "output file name (defaults to [in]_bits.go)")
	flags.StringVar(&cfg.tname, "type", "all", "struct to converted into bitfield (or all)")
	flags.StringVar(&cfg.pkgname, "pkg", "", "package name (defaults to input file package)")
	if err := flags.Parse(args); err != nil {
		return nil, buf.String(), err
	}

	if cfg.in == "" {
		return nil, "", fmt.Errorf("input file must be provided")
	}
	if cfg.out == "" {
		s, _ := strings.CutSuffix(cfg.in, ".go")
		cfg.out = s + "_bits.go"
	}

	return &cfg, buf.String(), nil
}

func main() {
	cfg, output, err := parseFlags(os.Args[1:])
	if err == flag.ErrHelp {
		fmt.Println(output)
		os.Exit(2)
	} else if err != nil {
		fmt.Fprint(os.Stderr, output)
		os.Exit(1)
	}

	if err := run(cfg); err != nil {
		fmt.Fprintf(os.Stderr, "bitfield, fatal error:\n")
		fmt.Fprintf(os.Stderr, "\t%s\n", err)
		os.Exit(1)
	}
}

type fieldInfo struct {
	Name   string
	Mask   string
	Offset int
	Bits   int   // actual bit count
	Width  uint8 // bits of the argument or return type
}

type structInfo struct {
	StructName string
	Width      uint8 // type width in bits
	unions     map[string]*union
}

func newStructInfo(name string) *structInfo {
	return &structInfo{
		StructName: name,
		unions:     make(map[string]*union),
	}
}

func (si *structInfo) union(name string) *union {
	if u, ok := si.unions[name]; ok {
		return u
	}
	u := &union{}
	si.unions[name] = u
	return u
}

type union struct {
	Fields []fieldInfo
	Bits   int // bits actually used
}

func run(cfg *config) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, cfg.in, nil, parser.ParseComments)
	if err != nil {
		return fmt.Errorf("failed to parse %s: %w", cfg.in, err)
	}

	var structs []*structInfo
	var tErr error
	ast.Inspect(node, func(n ast.Node) bool {
		t, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		s, ok := t.Type.(*ast.StructType)
		if !ok {
			return true
		}

		offsets := make(map[string]int)
		structInfo := newStructInfo(t.Name.Name)
		for _, field := range s.Fields.List {
			uname := "default"
			blocks := strings.Fields(strings.Trim(field.Tag.Value, "`"))
			for _, b := range blocks {
				if !strings.HasPrefix(b, "bitfield:") {
					continue
				}

				fieldName := field.Names[0].Name
				tags := strings.Split(strings.Trim(b[9:], `"`), ",")
				bits := 0
				for _, tag := range tags {
					k, v, ok := strings.Cut(tag, "=")
					if !ok {
						tErr = fmt.Errorf("field '%s' has a malformed struct tag", fieldName)
						return false
					}
					switch k {
					case "bits":
						ibits, err := strconv.Atoi(v)
						if err != nil {
							tErr = fmt.Errorf("failed to parse bit count for field '%s'", fieldName)
							return false
						}

						if ibits <= 0 || ibits > 64 {
							tErr = fmt.Errorf("field '%s' has an invalid bit count (%d), must be (0, 64]", fieldName, ibits)
							return false
						}
						bits = ibits
					case "union":
						uname = v
					}
				}

				if bits == 0 {
					tErr = fmt.Errorf("missing bit count for field '%s': %s", fieldName, tags)
					return false
				}

				if fieldName != "_" {
					u := structInfo.union(uname)
					u.Fields = append(u.Fields, fieldInfo{
						Name:   fieldName,
						Offset: offsets[uname],
						Bits:   bits,
						Mask:   fmt.Sprintf("0x%x", 1<<uint64(bits)-1),
						Width:  nextpow2(uint8(bits)),
					})
				}
				offsets[uname] += bits
			}
		}

		for n, u := range structInfo.unions {
			u.Bits = offsets[n]
			structInfo.Width = max(structInfo.Width, uint8(offsets[n]))
		}
		structInfo.Width = nextpow2(structInfo.Width)
		structs = append(structs, structInfo)
		return true
	})
	if tErr != nil {
		// Return the error set during the AST traversal.
		return tErr
	}

	if len(structs) == 0 {
		return fmt.Errorf("nothing to generate")
	}

	// Generate the file.
	if cfg.pkgname == "" {
		cfg.pkgname = node.Name.Name
	}
	gprintf("package %s\n\n", cfg.pkgname)
	gprintf("// Code generated by bitfield %s. DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))

	for _, si := range structs {
		gprintf(`type %s uint%d`, si.StructName, si.Width)
		for un, u := range si.unions {
			// Define the final type
			if u.Bits > 64 {
				if un == "default" {
					return fmt.Errorf("struct '%s' has too many bits (%d)", si.StructName, u.Bits)
				}
				return fmt.Errorf("struct '%s' has too many bits in union '%s' (%d)", si.StructName, un, u.Bits)
			}

			for _, fi := range u.Fields {
				// Getter
				if fi.Width < 8 {
					fi.Width = 8
				}
				typ := fmt.Sprintf("uint%d", fi.Width)
				gprintf(`func (s %s) %s() %s {`, si.StructName, fi.Name, typ)
				if fi.Offset > 0 {
					gprintf(`	return %s((s >> %d) & %s)`, typ, fi.Offset, fi.Mask)
				} else {
					gprintf(`	return %s(s & %s)`, typ, fi.Mask)
				}
				gprintf(`}`)
				gprintf(``)

				// Setter
				gprintf(`func (s %s) Set%s(val %s) %s {`, si.StructName, fi.Name, typ, si.StructName)
				if fi.Offset > 0 {
					gprintf(`	return s &^ (%s<<%d) | (MyStruct(val&%s)<<%d)`, fi.Mask, fi.Offset, fi.Mask, fi.Offset)
				} else {
					gprintf(`	return s &^ %s | MyStruct(val&%s)`, fi.Mask, fi.Mask)
				}
				gprintf(`}`)
				gprintf(``)
			}
		}
	}

	buf, err := format.Source(bb.Bytes())
	if err != nil {
		return fmt.Errorf("go format failed: %s", err)
	}
	if err := os.WriteFile(cfg.out, buf, 0666); err != nil {
		return fmt.Errorf("write failed: %s", err)
	}
	return nil
}

func gprintf(format string, args ...any) {
	fmt.Fprintf(&bb, "%s\n", fmt.Sprintf(format, args...))
}

func nextpow2(n uint8) uint8 {
	n--
	n |= n >> 1
	n |= n >> 2
	n |= n >> 4
	n++
	return n
}
