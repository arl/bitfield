package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"strconv"
	"strings"
)

type Field struct {
	Name   string
	Mask   string
	Offset int
	Bits   int   // actual bit count
	Width  uint8 // bits of the argument or return type
}

type StructInfo struct {
	StructName string
	Width      uint8 // type width in bits
	unions     map[string]*Union
}

func NewStructInfo(name string) *StructInfo {
	return &StructInfo{
		StructName: name,
		unions:     make(map[string]*Union),
	}
}

func (si *StructInfo) Union(name string) *Union {
	if u, ok := si.unions[name]; ok {
		return u
	}
	u := &Union{}
	si.unions[name] = u
	return u
}

type Union struct {
	Fields []Field
	Bits   int // bits actually used
}

var errMalformedTag = errors.New("malformed struct tag")
var errInvalidFieldSize = errors.New("invalid field size")

var bb bytes.Buffer

func main() {
	var (
		in, out string
		tname   string
		pkgname string
	)

	flag.StringVar(&in, "in", "", "input file name")
	flag.StringVar(&out, "out", "", "output file name (defaults to [in]_bits.go)")
	flag.StringVar(&tname, "type", "all", "struct to converted into bitfield (or all)")
	flag.StringVar(&pkgname, "pkg", "", "package name (defaults to input file package)")
	flag.Parse()

	if in == "" {
		fmt.Fprintf(os.Stderr, "input file must be provided\n")
		os.Exit(1)
	}
	if out == "" {
		s, _ := strings.CutSuffix(in, ".go")
		out = s + "_bits.go"
	}

	// Parse the file
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, in, nil, parser.ParseComments)
	checkf(err, "failed to parse %s", in)

	if pkgname == "" {
		pkgname = node.Name.Name
	}

	// Process the AST
	var structs []*StructInfo
	ast.Inspect(node, func(n ast.Node) bool {
		t, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		s, ok := t.Type.(*ast.StructType)
		if !ok {
			return true
		}

		offsets := make(map[string]int)
		structInfo := NewStructInfo(t.Name.Name)
		for _, field := range s.Fields.List {
			uname := "default"
			blocks := strings.Fields(strings.Trim(field.Tag.Value, "`"))
			for _, b := range blocks {
				if !strings.HasPrefix(b, "bitfield:") {
					continue
				}

				fieldName := field.Names[0].Name
				tags := strings.Split(strings.Trim(b[9:], `"`), ",")
				bits := 0
				for _, tag := range tags {
					k, v, ok := strings.Cut(tag, "=")
					if !ok {
						checkf(errMalformedTag, "field '%s' has a malformed struct tag", fieldName)
					}
					switch k {
					case "bits":
						ibits, err := strconv.Atoi(v)
						checkf(err, "failed to parse bit count for field '%s'", fieldName)
						if ibits <= 0 || ibits > 64 {
							fatalf("field '%s' has an invalid bit count (%d). Must be (0, 64]", fieldName, ibits)
						}
						bits = ibits
					case "union":
						uname = v
					}
				}

				if bits == 0 {
					checkf(errInvalidFieldSize, "missing bit count for field '%s': %s", fieldName, tags)
				}

				if fieldName != "_" {
					u := structInfo.Union(uname)
					u.Fields = append(u.Fields, Field{
						Name:   fieldName,
						Offset: offsets[uname],
						Bits:   bits,
						Mask:   fmt.Sprintf("0x%x", 1<<uint64(bits)-1),
						Width:  nextpow2(uint8(bits)),
					})
				}
				offsets[uname] += bits
			}
		}

		for n, u := range structInfo.unions {
			u.Bits = offsets[n]
			structInfo.Width = max(structInfo.Width, uint8(offsets[n]))
		}
		structInfo.Width = nextpow2(structInfo.Width)
		structs = append(structs, structInfo)
		return false
	})

	if len(structs) == 0 {
		fmt.Fprintf(os.Stderr, "nothing to generate")
		return
	}

	// Generate the file.
	gprintf("package %s\n\n", pkgname)
	gprintf("// Code generated by %s %s. DO NOT EDIT.\n", os.Args[0], strings.Join(os.Args[1:], " "))

	for _, si := range structs {
		gprintf(`type %s uint%d`, si.StructName, si.Width)
		for un, u := range si.unions {
			// Define the final type
			if u.Bits > 64 {
				if un == "default" {
					fatalf("struct '%s' has too many bits (%d)", si.StructName, u.Bits)
				}
				fatalf("struct '%s' has too many bits in union '%s' (%d)", si.StructName, un, u.Bits)
			}

			for _, fi := range u.Fields {
				// Getter
				if fi.Width < 8 {
					fi.Width = 8
				}
				typ := fmt.Sprintf("uint%d", fi.Width)
				gprintf(`func (s %s) %s() %s {`, si.StructName, fi.Name, typ)
				if fi.Offset > 0 {
					gprintf(`	return %s((s >> %d) & %s)`, typ, fi.Offset, fi.Mask)
				} else {
					gprintf(`	return %s(s & %s)`, typ, fi.Mask)
				}
				gprintf(`}`)
				gprintf(``)

				// Setter
				gprintf(`func (s %s) Set%s(val %s) %s {`, si.StructName, fi.Name, typ, si.StructName)
				if fi.Offset > 0 {
					gprintf(`	return s &^ (%s<<%d) | (MyStruct(val&%s)<<%d)`, fi.Mask, fi.Offset, fi.Mask, fi.Offset)
				} else {
					gprintf(`	return s &^ %s | MyStruct(val&%s)`, fi.Mask, fi.Mask)
				}
				gprintf(`}`)
				gprintf(``)
			}
		}
	}

	buf, err := format.Source(bb.Bytes())
	checkf(err, "go format failed:\n\n%s", bb.String())
	checkf(os.WriteFile(out, buf, 0666), "write failed")
}

func gprintf(format string, args ...any) {
	fmt.Fprintf(&bb, "%s\n", fmt.Sprintf(format, args...))
}

func checkf(err error, format string, args ...any) {
	if err == nil {
		return
	}

	fmt.Fprintf(os.Stderr, "bitfield, fatal error:")
	fmt.Fprintf(os.Stderr, "\n\t%s: %s\n", fmt.Sprintf(format, args...), err)
	os.Exit(1)
}

func fatalf(format string, args ...any) {
	fmt.Fprintf(os.Stderr, "bitfield, fatal error:")
	fmt.Fprintf(os.Stderr, "\n\t%s\n", fmt.Sprintf(format, args...))
	os.Exit(1)
}

func nextpow2(n uint8) uint8 {
	n--
	n |= n >> 1
	n |= n >> 2
	n |= n >> 4
	n++
	return n
}
